<!-- Latency Distribution Chart Component -->
<div class="chart-container" 
     data-chart-type="latency-distribution"
     data-refresh-interval="{{ config.refresh_interval }}"
     data-time-range="{{ config.time_range }}">
    
    <div class="chart-header d-flex justify-content-between align-items-center mb-3">
        <div>
            <h5 class="mb-0">{{ config.title or 'Latency Distribution' }}</h5>
            <small class="text-muted">Response time histogram</small>
        </div>
        <div class="chart-controls">
            <div class="btn-group btn-group-sm" role="group">
                <button type="button" class="btn btn-outline-secondary active" data-period="1h">1H</button>
                <button type="button" class="btn btn-outline-secondary" data-period="24h">24H</button>
                <button type="button" class="btn btn-outline-secondary" data-period="7d">7D</button>
            </div>
            <button class="btn btn-sm btn-outline-secondary ms-2" id="export-latency-chart">
                <i class="bi bi-download"></i>
            </button>
        </div>
    </div>
    
    <div class="latency-stats mb-3">
        <div class="row">
            <div class="col-md-3">
                <div class="stat-card text-center p-2 border rounded">
                    <div class="stat-number" id="min-latency">-</div>
                    <div class="stat-label">Min (ms)</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stat-card text-center p-2 border rounded">
                    <div class="stat-number" id="avg-latency">-</div>
                    <div class="stat-label">Avg (ms)</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stat-card text-center p-2 border rounded">
                    <div class="stat-number" id="p95-latency">-</div>
                    <div class="stat-label">P95 (ms)</div>
                </div>
            </div>
            <div class="col-md-3">
                <div class="stat-card text-center p-2 border rounded">
                    <div class="stat-number" id="max-latency">-</div>
                    <div class="stat-label">Max (ms)</div>
                </div>
            </div>
        </div>
    </div>
    
    <div class="chart-wrapper" style="height: {{ config.height }}px; width: {{ config.width }};">
        <canvas id="latency-dist-chart-{{ range(1000) | random }}"></canvas>
    </div>
    
    <div class="chart-loading d-none">
        <div class="text-center p-4">
            <div class="spinner-border" role="status">
                <span class="visually-hidden">Loading...</span>
            </div>
        </div>
    </div>
    
    <div class="chart-error d-none">
        <div class="alert alert-warning" role="alert">
            Failed to load latency distribution. <a href="#" class="retry-chart">Retry</a>
        </div>
    </div>
</div>

<style>
.stat-card {
    background: rgba(255, 255, 255, 0.5);
    transition: all 0.3s ease;
}

.stat-card:hover {
    background: rgba(255, 255, 255, 0.8);
    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
}

.stat-number {
    font-size: 1.25rem;
    font-weight: bold;
    color: #495057;
    line-height: 1;
}

.stat-label {
    font-size: 0.75rem;
    color: #6c757d;
    margin-top: 4px;
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
    const container = document.querySelector('[data-chart-type="latency-distribution"]');
    const canvas = container.querySelector('canvas');
    
    let chart = null;
    let refreshInterval = null;
    let currentPeriod = '1h';
    
    function loadChart() {
        showLoading(true);
        
        const params = new URLSearchParams({
            hours: currentPeriod === '1h' ? 1 : currentPeriod === '24h' ? 24 : 168
        });
        
        fetch(`/components/chart-data/latency-distribution?${params}`)
            .then(response => response.json())
            .then(data => {
                if (chart) chart.destroy();
                
                const ctx = canvas.getContext('2d');
                chart = new Chart(ctx, data);
                
                updateLatencyStats(data);
                
                showLoading(false);
                showError(false);
            })
            .catch(error => {
                console.error('Error loading latency distribution:', error);
                showLoading(false);
                showError(true);
            });
    }
    
    function updateLatencyStats(chartData) {
        // Calculate stats from chart data
        if (chartData.data && chartData.data.datasets[0]) {
            const data = chartData.data.datasets[0].data;
            const labels = chartData.data.labels;
            
            let totalRequests = data.reduce((sum, val) => sum + val, 0);
            let weightedSum = 0;
            let minLatency = Infinity;
            let maxLatency = 0;
            let p95Requests = 0;
            let p95Latency = 0;
            
            // Calculate weighted average and find min/max
            data.forEach((count, index) => {
                if (count > 0) {
                    // Extract average latency from label (e.g., "100.0-200.0ms")
                    const labelParts = labels[index].split('-');
                    const binStart = parseFloat(labelParts[0]);
                    const binEnd = parseFloat(labelParts[1].replace('ms', ''));
                    const binMid = (binStart + binEnd) / 2;
                    
                    weightedSum += binMid * count;
                    minLatency = Math.min(minLatency, binStart);
                    maxLatency = Math.max(maxLatency, binEnd);
                }
            });
            
            // Calculate P95
            const p95Threshold = totalRequests * 0.95;
            let cumulativeCount = 0;
            for (let i = 0; i < data.length; i++) {
                cumulativeCount += data[i];
                if (cumulativeCount >= p95Threshold) {
                    const labelParts = labels[i].split('-');
                    p95Latency = parseFloat(labelParts[1].replace('ms', ''));
                    break;
                }
            }
            
            const avgLatency = totalRequests > 0 ? weightedSum / totalRequests : 0;
            
            document.getElementById('min-latency').textContent = 
                minLatency === Infinity ? '-' : minLatency.toFixed(1);
            document.getElementById('avg-latency').textContent = 
                avgLatency.toFixed(1);
            document.getElementById('p95-latency').textContent = 
                p95Latency.toFixed(1);
            document.getElementById('max-latency').textContent = 
                maxLatency.toFixed(1);
        }
    }
    
    function showLoading(show) {
        container.querySelector('.chart-loading').classList.toggle('d-none', !show);
        container.querySelector('.chart-wrapper').classList.toggle('d-none', show);
        container.querySelector('.latency-stats').classList.toggle('d-none', show);
    }
    
    function showError(show) {
        container.querySelector('.chart-error').classList.toggle('d-none', !show);
        container.querySelector('.chart-wrapper').classList.toggle('d-none', show);
        container.querySelector('.latency-stats').classList.toggle('d-none', show);
    }
    
    // Period selection
    container.querySelectorAll('[data-period]').forEach(btn => {
        btn.addEventListener('click', function() {
            container.querySelectorAll('[data-period]').forEach(b => b.classList.remove('active'));
            this.classList.add('active');
            currentPeriod = this.dataset.period;
            loadChart();
        });
    });
    
    // Export button
    container.querySelector('#export-latency-chart').addEventListener('click', function() {
        if (chart) {
            const url = chart.toBase64Image();
            const link = document.createElement('a');
            link.download = 'latency-distribution.png';
            link.href = url;
            link.click();
        }
    });
    
    // Retry button
    container.querySelector('.retry-chart').addEventListener('click', function(e) {
        e.preventDefault();
        loadChart();
    });
    
    // Auto-refresh
    function startRefresh() {
        const interval = parseInt(container.dataset.refreshInterval) * 1000;
        refreshInterval = setInterval(loadChart, interval);
    }
    
    // Initial load
    loadChart();
    startRefresh();
    
    // Cleanup
    window.addEventListener('beforeunload', function() {
        if (refreshInterval) clearInterval(refreshInterval);
        if (chart) chart.destroy();
    });
});
</script>